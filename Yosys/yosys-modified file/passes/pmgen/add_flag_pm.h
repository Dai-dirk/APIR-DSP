// Generated by pmgen.py from passes/pmgen/add_flag.pmg

struct add_flag_pm {
  Module *module;
  SigMap sigmap;
  std::function<void()> on_accept;
  bool setup_done;
  bool generate_mode;
  int accept_cnt;

  uint32_t rngseed;
  int rng(unsigned int n) {
    rngseed ^= rngseed << 13;
    rngseed ^= rngseed >> 17;
    rngseed ^= rngseed << 5;
    return rngseed % n;
  }

  typedef std::tuple<> index_0_key_type;
  typedef std::tuple<Cell*> index_0_value_type;
  dict<index_0_key_type, vector<index_0_value_type>> index_0;
  typedef std::tuple<> index_7_key_type;
  typedef std::tuple<Cell*> index_7_value_type;
  dict<index_7_key_type, vector<index_7_value_type>> index_7;
  dict<SigBit, pool<Cell*>> sigusers;
  pool<Cell*> blacklist_cells;
  pool<Cell*> autoremove_cells;
  dict<Cell*,int> rollback_cache;
  int rollback;

  struct state_add_flag_t {
    Cell* add;
    SigSpec argD;
    SigSpec argQ;
    SigBit clock;
    Cell* ff;
    Cell* ffA;
    Cell* ffB;
    int ffoffset;
    SigSpec sigA;
    SigSpec sigB;
  } st_add_flag;

  struct udata_add_flag_t {
    Cell* dff;
    SigSpec dffD;
    SigSpec dffQ;
    SigBit dffclock;
    std::function<SigSpec(const SigSpec&)> unextend;
  } ud_add_flag;

  IdString id_b_A{"\\A"};
  IdString id_b_B{"\\B"};
  IdString id_b_DSP48E2{"\\DSP48E2"};
  IdString id_b_apirdsp{"\\apirdsp"};
  IdString id_b_init{"\\init"};
  IdString id_b_keep{"\\keep"};
  IdString id_d___add_flag{"$__add_flag"};

  void add_siguser(const SigSpec &sig, Cell *cell) {
    for (auto bit : sigmap(sig)) {
      if (bit.wire == nullptr) continue;
      sigusers[bit].insert(cell);
    }
  }

  void blacklist(Cell *cell) {
    if (cell != nullptr && blacklist_cells.insert(cell).second) {
      auto ptr = rollback_cache.find(cell);
      if (ptr == rollback_cache.end()) return;
      int rb = ptr->second;
      if (rollback == 0 || rollback > rb)
        rollback = rb;
    }
  }

  void autoremove(Cell *cell) {
    if (cell != nullptr) {
      autoremove_cells.insert(cell);
      blacklist(cell);
    }
  }

  SigSpec port(Cell *cell, IdString portname) {
    return sigmap(cell->getPort(portname));
  }

  SigSpec port(Cell *cell, IdString portname, const SigSpec& defval) {
    return sigmap(cell->connections_.at(portname, defval));
  }

  Const param(Cell *cell, IdString paramname) {
    return cell->getParam(paramname);
  }

  Const param(Cell *cell, IdString paramname, const Const& defval) {
    return cell->parameters.at(paramname, defval);
  }

  int nusers(const SigSpec &sig) {
    pool<Cell*> users;
    for (auto bit : sigmap(sig))
      for (auto user : sigusers[bit])
        users.insert(user);
    return GetSize(users);
  }

  add_flag_pm(Module *module, const vector<Cell*> &cells) :
      module(module), sigmap(module), setup_done(false), generate_mode(false), rngseed(12345678) {
    setup(cells);
  }

  add_flag_pm(Module *module) :
      module(module), sigmap(module), setup_done(false), generate_mode(false), rngseed(12345678) {
  }

  void setup(const vector<Cell*> &cells) {
    ud_add_flag.dff = nullptr;
    ud_add_flag.dffD = SigSpec();
    ud_add_flag.dffQ = SigSpec();
    ud_add_flag.dffclock = SigBit();
    ud_add_flag.unextend = std::function<SigSpec(const SigSpec&)>();
    log_assert(!setup_done);
    setup_done = true;
    for (auto port : module->ports)
      add_siguser(module->wire(port), nullptr);
    for (auto cell : module->cells())
      for (auto &conn : cell->connections())
        add_siguser(conn.second, cell);
    for (auto cell : cells) {
      do {
        Cell *add = cell;
        index_0_value_type value;
        std::get<0>(value) = cell;
        if (!(add->type.in(id_d___add_flag))) continue;
        index_0_key_type key;
        index_0[key].push_back(value);
      } while (0);
      do {
        Cell *ff = cell;
        index_7_value_type value;
        std::get<0>(value) = cell;
        if (!(ff->type.in(id_b_DSP48E2,id_b_apirdsp))) continue;
        index_7_key_type key;
        index_7[key].push_back(value);
      } while (0);
    }
  }

  ~add_flag_pm() {
    for (auto cell : autoremove_cells)
      module->remove(cell);
  }

  int run_add_flag(std::function<void()> on_accept_f) {
    log_assert(setup_done);
    accept_cnt = 0;
    on_accept = on_accept_f;
    rollback = 0;
    st_add_flag.add = nullptr;
    st_add_flag.argD = SigSpec();
    st_add_flag.argQ = SigSpec();
    st_add_flag.clock = SigBit();
    st_add_flag.ff = nullptr;
    st_add_flag.ffA = nullptr;
    st_add_flag.ffB = nullptr;
    st_add_flag.ffoffset = int();
    st_add_flag.sigA = SigSpec();
    st_add_flag.sigB = SigSpec();
    block_0(1);
    log_assert(rollback_cache.empty());
    return accept_cnt;
  }

  int run_add_flag(std::function<void(add_flag_pm&)> on_accept_f) {
    return run_add_flag([&](){on_accept_f(*this);});
  }

  int run_add_flag() {
    return run_add_flag([](){});
  }

  void block_subpattern_add_flag_(int recursion) { block_0(recursion); }
  void block_subpattern_add_flag_flag(int recursion) { block_6(recursion); }

  // passes/pmgen/add_flag.pmg:18
  void block_0(int recursion YS_MAYBE_UNUSED) {
    Cell* &add YS_MAYBE_UNUSED = st_add_flag.add;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;
    Cell* _pmg_backup_add = add;

    index_0_key_type key;
    auto cells_ptr = index_0.find(key);

    if (cells_ptr != index_0.end()) {
      const vector<index_0_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        add = std::get<0>(cells[_pmg_idx]);
        if (blacklist_cells.count(add)) continue;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_1(recursion+1);
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            add = _pmg_backup_add;
            return;
          }
          rollback = 0;
        }
      }
    }

    add = nullptr;
    add = _pmg_backup_add;
  }

  // passes/pmgen/add_flag.pmg:22
  void block_1(int recursion YS_MAYBE_UNUSED) {
    Cell* const &add YS_MAYBE_UNUSED = st_add_flag.add;
    SigSpec &sigA YS_MAYBE_UNUSED = st_add_flag.sigA;
    SigSpec &sigB YS_MAYBE_UNUSED = st_add_flag.sigB;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_2(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_add_flag_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    unextend = [](const SigSpec &sig) {
      int i;
      for (i = GetSize(sig)-1; i > 0; i--)
        if (sig[i] != sig[i-1])
          break;
      // Do not remove non-const sign bit
      if (sig[i].wire)
        ++i;
      return sig.extract(0, i);
    };
    sigA = unextend(port(add, id_b_A, SigSpec()));
          sigB = unextend(port(add, id_b_B, SigSpec()));

    block_2(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_MAYBE_UNUSED;

    sigA = SigSpec();
    sigB = SigSpec();
  }

  // passes/pmgen/add_flag.pmg:38
  void block_2(int recursion YS_MAYBE_UNUSED) {
    Cell* const &add YS_MAYBE_UNUSED = st_add_flag.add;
    const SigSpec &sigB YS_MAYBE_UNUSED = st_add_flag.sigB;
    SigSpec &argQ YS_MAYBE_UNUSED = st_add_flag.argQ;
    Cell* &ffA YS_MAYBE_UNUSED = st_add_flag.ffA;
    SigSpec &sigA YS_MAYBE_UNUSED = st_add_flag.sigA;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;

    SigSpec _pmg_backup_sigA = sigA;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_3(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_add_flag_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    argQ = sigA;
    subpattern(flag);
    if (dff) {
      ffA = dff;
    }

    block_3(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_MAYBE_UNUSED;

    sigA = _pmg_backup_sigA;
    argQ = SigSpec();
    ffA = nullptr;
  }

  // passes/pmgen/add_flag.pmg:46
  void block_3(int recursion YS_MAYBE_UNUSED) {
    Cell* const &add YS_MAYBE_UNUSED = st_add_flag.add;
    Cell* const &ffA YS_MAYBE_UNUSED = st_add_flag.ffA;
    const SigSpec &sigA YS_MAYBE_UNUSED = st_add_flag.sigA;
    SigSpec &argQ YS_MAYBE_UNUSED = st_add_flag.argQ;
    SigBit &clock YS_MAYBE_UNUSED = st_add_flag.clock;
    Cell* &ffB YS_MAYBE_UNUSED = st_add_flag.ffB;
    SigSpec &sigB YS_MAYBE_UNUSED = st_add_flag.sigB;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;

    SigSpec _pmg_backup_argQ = argQ;
    SigSpec _pmg_backup_sigB = sigB;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_4(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_add_flag_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    argQ = sigB;
    subpattern(flag);
    if (dff) {
      ffB = dff;
    }

    block_4(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_MAYBE_UNUSED;

    argQ = _pmg_backup_argQ;
    sigB = _pmg_backup_sigB;
    clock = SigBit();
    ffB = nullptr;
  }

  // passes/pmgen/add_flag.pmg:54
  void block_4(int recursion YS_MAYBE_UNUSED) {
    Cell* const &add YS_MAYBE_UNUSED = st_add_flag.add;
    const SigSpec &argQ YS_MAYBE_UNUSED = st_add_flag.argQ;
    const SigBit &clock YS_MAYBE_UNUSED = st_add_flag.clock;
    Cell* const &ffA YS_MAYBE_UNUSED = st_add_flag.ffA;
    Cell* const &ffB YS_MAYBE_UNUSED = st_add_flag.ffB;
    const SigSpec &sigA YS_MAYBE_UNUSED = st_add_flag.sigA;
    const SigSpec &sigB YS_MAYBE_UNUSED = st_add_flag.sigB;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_5(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_add_flag_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if ((ffA&&ffB))
      accept;

    block_5(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_MAYBE_UNUSED;
  }

  void block_5(int recursion YS_MAYBE_UNUSED) {
  }

  // passes/pmgen/add_flag.pmg:66
  void block_6(int recursion YS_MAYBE_UNUSED) {
    const SigSpec &argQ YS_MAYBE_UNUSED = st_add_flag.argQ;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_7(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_add_flag_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    dff = nullptr;
    if (argQ.empty())
      reject;
    for (const auto &c : argQ.chunks()) {
      // Abandon matches when 'Q' is a constant
      if (!c.wire)
        reject;
      // Abandon matches when 'Q' has the keep attribute set
      if (c.wire->get_bool_attribute(id_b_keep))
        reject;
      // Abandon matches when 'Q' has a non-zero init attribute set
      // (not supported by DSP48E1)
      Const init = c.wire->attributes.at(id_b_init, Const());
      if (!init.empty())
        for (auto b : init.extract(c.offset, c.width))
          if (b != State::Sx && b != State::S0)
            reject;
    }

    block_7(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_MAYBE_UNUSED;
  }

  // passes/pmgen/add_flag.pmg:87
  void block_7(int recursion YS_MAYBE_UNUSED) {
    const SigSpec &argQ YS_MAYBE_UNUSED = st_add_flag.argQ;
    Cell* &ff YS_MAYBE_UNUSED = st_add_flag.ff;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;
    Cell* _pmg_backup_ff = ff;

    index_7_key_type key;
    auto cells_ptr = index_7.find(key);

    if (cells_ptr != index_7.end()) {
      const vector<index_7_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        ff = std::get<0>(cells[_pmg_idx]);
        if (blacklist_cells.count(ff)) continue;
        if (!(ff->type.in(id_b_DSP48E2,id_b_apirdsp))) continue;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_8(recursion+1);
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            ff = _pmg_backup_ff;
            return;
          }
          rollback = 0;
        }
      }
    }

    ff = nullptr;
    ff = _pmg_backup_ff;
  }

  // passes/pmgen/add_flag.pmg:93
  void block_8(int recursion YS_MAYBE_UNUSED) {
    Cell* const &ff YS_MAYBE_UNUSED = st_add_flag.ff;
    SigSpec &argQ YS_MAYBE_UNUSED = st_add_flag.argQ;
    Cell* &dff YS_MAYBE_UNUSED = ud_add_flag.dff;
    SigSpec &dffD YS_MAYBE_UNUSED = ud_add_flag.dffD;
    SigSpec &dffQ YS_MAYBE_UNUSED = ud_add_flag.dffQ;
    SigBit &dffclock YS_MAYBE_UNUSED = ud_add_flag.dffclock;
    std::function<SigSpec(const SigSpec&)> &unextend YS_MAYBE_UNUSED = ud_add_flag.unextend;

    SigSpec _pmg_backup_argQ = argQ;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_9(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_add_flag_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    dff = ff;

    block_9(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_MAYBE_UNUSED;

    argQ = _pmg_backup_argQ;
  }

  void block_9(int recursion YS_MAYBE_UNUSED) {
  }
};
